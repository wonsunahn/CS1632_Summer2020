# Exercise 6 Property-based Testing Exercise

For this exercise, you will practice a software testing technique called
property-based testing.  Please review Lecture 14: Property-based Testing
before starting on this exercise.  Property-based testing is a type of dynamic
testing but differs from your regular unit testing in that it tests properties
rather than individual values to check behavior.  Instead of saying: "for this
particular set of input values, I expect this output value to be returned", a
property says: "regardless of what input values are provided, I expect this
property to hold no matter what".

The fact that a property is invariant across the entire set of inputs allows a
property-based test to be used with any input.  That means, instead of manually
encoding inputs (say, as part of JUnit test scripts), we can even auto-generate
some random inputs and test them against our property!  This type of testing
is called stochastic testing, or random testing.  Stochastic testing is a
synonym for property-based testing.  And by the way, this broad applicability
of properties is what made them so useful for model checking and exhaustive
program state space exploration in Exercise 5.

For this exercise, we are going to use a JUnit extension library called
QuickCheck.  Existing JUnit annotations such as @Test, @Before, @After still
apply as usual but we are going to learn about some new annotations that enable
us to do property-based testing.

## Description

IntegerOps.java - Methods to perform simple integer arithmetic such as add and subtract (modify).

StringsOps.java - Methods to perform some String operations such as checking whether two strings are equal and checking a string is valid HTML (modify).

IntegerOpsTest.java - A QuickCheck JUnit class that performs property-based testing on IntegerOps (modify).

StringOpsTest.java - A QuickCheck JUnit class that performs property-based testing on StringOps (modify).

ABCStringGenerator.java - A QuickCheck generator class that generates random strings containing the characters 'A', 'B', and 'C'.

HTMLStringGenerator.java - A QuickCheck generator class that generates random strings containing HTML tags such as <b>, </b>, <i>, </i> (modify).

TestRunner.java - Driver class that contains the main method to invoke JUnit on IntegerOpsTest and StringOpsTest.

## How to Run QuickCheck

1. Running QuickCheck. For Windows do:
    ```
    runTest.bat
    ```
1. For Mac / Linux do:
    ```
    bash runTest.sh
    ```    

Initially, you should see the usual "ALL TESTS PASSED" message.

Alternatively, I've created an Eclipse project for you so you can use Eclipse
to import the existing project and run either IntegerOpsTest or StringOpsTest
individually as JUnit classes.

## What to do

The goal is to debug IntegerOps and StringOps using the QuickCheck test classes
IntegerOpsTest and StringOpsTest.  The QuickCheck classes are incomplete as of
now so you will have to complete those first.  All places where you need to
modify are marked by // TODO comments.  Pay close attention to the Javadoc
comment above each method that describes what each method does, or is supposed
to do.

### IntegerOpsTest

Open IntegerOpsTest.java.  Look at the testAdd method:

```
@Property(trials = 1000)
public void testAdd(int x, int y) {
	// System.out.println("testAdd x='" + x + "', y='" + y + "'");
	// TODO: Fill in.
}
```

Note that each method has the @Property(trials = 1000) annotation.  The
@Property annotation tells QuickCheck that this is a property-based test and
QuickCheck is to do 1000 trial runs using 1000 randomized input values.  Note
that unlike a regular @Test JUnit method, an @Property method has input
parameters x and y.  These input parameters are where the randomized input
values generated by QuickCheck are passed.  So on each of the 1000 trials, x
and y will be passed a different value.  Not only that, the first time you run
it with the 1000 trials will be different from the second set of 1000 trials
(that is, x and y are going to be different values).  You can observe this
yourself by un-commenting the System.out.println.  That is the beauty of
property-based testing: as you run the tests repeatedly, you will gradually
gain higher coverage without you having to do anything!

Now it's time to fill in the method.  Fill in the code according to the
invariant property specified in the Javadoc comment above the method.  If you
implemented it properly, you should get something similar to the following
message when you execute runTest.bat again (actual numbers may differ due to
randomness):

```
testAdd(IntegerOpsTest): Property named 'testAdd' failed:
With arguments: [1091099725, 1056406418]
First arguments found to also provoke a failure: [1936803025, 1056406418]
```

This is telling you that QuickCheck was able to determine that testAdd fails
when x = 1091099725 and y = 1056406418.  What is the part about: "First
arguments found to also provoke a failure"?  That's telling you that among the
1000 trials, [1936803025, 1056406418] were the first set of values where a
defect was found.  From those values, QuickCheck progressively refined or
"shrunk" them to the final values [1091099725, 1056406418].  QuickCheck always
tries to "shrink" input values to the simplest or smallest values that still
trigger the defect to make debugging easier.  Rather that just reporting
[1936803025, 1056406418], [1091099725, 1056406418] gives you more information.
1091099725 + 1056406418 = 2147506143 which is just slightly bigger than
Integer.MAX_VALUE = 2147483647.  So this strongly suggests the defect has
something to do with integer overflow.  Otherwise, we would have had to find
this out by trial-and-error.

If you left the System.out.println un-commented, you can see what's happening
behind the scenes by observing the output:

```
testAdd x='-1967126952', y='1194075525'
testAdd x='1191001002', y='529527415'
testAdd x='-427676937', y='1415513158'
testAdd x='898946678', y='-810210174'
testAdd x='-2096855516', y='147305889'
testAdd x='-1427326142', y='201626672'
testAdd x='927999071', y='-507009504'
testAdd x='-1575502058', y='-1850940687'
testAdd x='-82004065', y='-1320953857'
testAdd x='275074581', y='-1498381415'
testAdd x='1936803025', y='1056406418'  <--- First discovery of defect, starting shrinking ...
testAdd x='0', y='1056406418'
testAdd x='968401512', y='1056406418'
testAdd x='1452602268', y='1056406418'
testAdd x='0', y='1056406418'
testAdd x='726301134', y='1056406418'
testAdd x='1089451701', y='1056406418'
...
testAdd x='1090899926', y='1056406418'
testAdd x='1091033125', y='1056406418'
testAdd x='1091099725', y='1056406418'  <--- Smallest input while still triggering defect
testAdd x='0', y='1056406418'
testAdd x='545549862', y='1056406418'
testAdd x='818324793', y='1056406418'
testAdd x='954712259', y='1056406418'
...
```

You can see how QuickCheck is methodically doing the trial-and-error behind the
scenes, so that you don't have to do it.

Now debug IntegerOps.add(int x, int y) so that the test passes.  All you have
to do is: if you detect integer overflow (you add two positive numbers but you
end up with a negative number), then return 0.

Complete testSubstract in the same way and debug IntegerOps.subtract(int x, int
y).

### IntegerOpsTest Lessons

These are the three things you should have learned through this exercise:
1. A @Property QuickCheck test goes through many randomized trials during a
   single test run where each trial is provided with randomized input values.
1. A property check must be an invariant assertion that is true no matter what
   randomized input values are tested.  For example, things like: the addition
of two positive integer should result in a positive integer.
1. When a @Property test fails, not only does QuickCheck provide you with the
   set of input values triggering the defect, but it also "shrinks" them to the
smallest set of defect-triggering values meant to help you debug.

### StringOpsTest

Open StringOpsTest.java.  Look at the testEquals method:

```
@Property(trials = 1000)
public void testEquals(String s1, String s2) {
	// System.out.println("testEquals s1='" + s1 + "', s2='" + s2 + "'");
	// TODO: Fill in.
}
```

Fill in the test as before based on the Javadoc comments.  Now, this time, even
after filling in the test the test passes (and it will pass no matter how many
times you run it unless you are very lucky).  Does that mean StringOps is
bug-free?  Absolutely not!  If you see StringOps.equals(String s1, String s2),
you can see the two strings are compared only up to Integer.min(s1.length(),
s2.length()).  So if one string is shorter than the other, but the two strings
are identical up to that point, equals will return true.  That cannot be
correct behavior.

Why wasn't the defect caught during the 1000 trials?  That is because the
defect manifests only when s1 and s2 fit a certain pattern (they are identical
up to a certain point).  And given uniform distribution, it is very unlikely
that s1 and s2 will show any resemblance whatsoever.  If you uncomment
System.out.println and observe the strings passed, you will see what I mean.

That means we have to generate a distribution more likely to uncover the
defect.  Remember in Lecture 14, I stressed that stochastic testing requires a
lot of thinking about the distribution you generate in order to be effective?
This is just such a case.  Modify the testEquals method declaration as such to
use @From annotations:

```
@Property(trials = 1000)
public void testEquals(@From(ABCStringGenerator.class) String s1, @From(ABCStringGenerator.class) String s2) {
	...
}
```

The @From annotation tells QuickCheck to use the ABCStringGenerator.class
instead of the default uniform String generator to generate s1 and s2.  Open
ABCStringGenerator.java, and focus on the overridden generate method.  I
overrode the default method such that now the generated strings only contain
'A's, 'B's, and 'C's.  This greatly increases the chance that the two strings
will resemble each other, giving us a better chance of uncovering the defect.
Once you make the change, testEquals should fail after one or two runs.  Note
how I also overrode the doShrink method

```
@Override
public List<String> doShrink(SourceOfRandomness random, String larger) {
	if (larger.length() == 0)
		return Collections.emptyList();

	// In this case, the string is shrunk simply by chopping it in half.
	// Both the left and right half are added to the list of strings to check.
	List<String> list = new ArrayList<>();
	list.add(larger.substring(0, larger.length() / 2));
	list.add(larger.substring(larger.length() / 2));
	return list;
}
```

If a String fails a test, it is chopped in half and the lower half and upper
half are tried again respectively.  Implementing the doShrink method allows
QuickCheck to shrink the input values just like before:

```
testEquals(StringOpsTest): Property named 'testEquals' failed:
With arguments: [, A]
First arguments found to also provoke a failure: [AB, ABC]
```

Inputs [AB, ABC] has been shrunk to [, A].  You can see how this is easier to
debug.  The progressive shrinking happens as before:

```
testEquals s1='', s2=''
testEquals s1='AB', s2='ABC'
testEquals s1='A', s2='ABC'
testEquals s1='', s2='ABC'
testEquals s1='', s2='A'
testEquals s1='', s2=''
```

Now it's time to look at the testIsValidHTML method:

```
@Property(trials = 1000)
public void testIsValidHTML(String s) {
	// System.out.println("testIsValidHTML s='" + s + "'");
	// TODO: Fill in.
}
```

Again, fill in according to the Javadoc comment.  But even after filling in the
test, the test never fails due to the uniform distribution.  The method only
checks the invariant assertion when "StringOps.isValidHTML(s) returns true"
according to the comment.  And it is very difficult to randomly hit on a string
that is valid HTML given the uniform distribution.  So we need a different
generator just like before, namely the HTMLStringGenerator.

```
@Property(trials = 1000)
public void testIsValidHTML(@From(HTMLStringGenerator.class) String s) {
	...
}
```

HTMLStringGenerator is incomplete as of now.  Fill in the generate and doShrink
methods after reading the comments and comparing against ABCStringGenerator.
HTMLStringGenerator generates a random sequence of HTML tags which is much more
likely to show good coverage compared to the uniform distribution.  After
properly implementing, the above test should start to fail.  Debug
StringOps.isValidHTML so that now all tests pass.

### StringOpsTest Lessons

These are the two things you should have learned through this exercise:
1. Sometimes a program functions meaningfully only for a certain pattern of
   inputs.  In these situations, going with the default uniform distribution of
inputs will lead to horrible test coverage.
1. QuickCheck allows you to create your own generator by inheriting from
   existing generators and overriding some methods.  This allows you to
customize your own distribution.  In this exercise, we only practiced
generating integers and Strings but there is nothing preventing you from
generating objects.  For example, in the above StringOpsTest.testEquals(String
s1, String s2) method, we could have generated the two strings s1 and s2 as
part of the same object such that we correlate s1 and s2 in some way rather
than generating them separately.

## Submission

You will create a GitHub repository just for Exercise 6.  Add your partner as a
collaborator so both of you have access.  Make sure you keep the repository
*PRIVATE* so that nobody else can access your repository.  Once you are done
modifying code, don't forget to commit and push your changes to the repository.
When you are done, submit your repository to GradeScope at the "Exercise 6
GitHub" link.  

Please submit by Friday (7/10) 06:00 PM to get timely feedback.

## Extra Credit

I am cooking up an extra credit related to this exercise.  I will announce it by the end of the week.
